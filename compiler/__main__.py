# Example usage
from compiler.lexer.lexer import Lexer
from compiler.parser.parser import Parser
from compiler.codegen.codegen import CodeGenerator

def display_error(error, source_lines):
    line_num = error.token.line
    col_num = error.token.column
    token_val = error.token.value
    token_len = max(len(token_val), 1)

    line_text = source_lines[line_num - 1].replace('\t', '    ')  # Convert tabs to spaces

    # Account for tabs in spacing
    pointer_line = ' ' * (col_num - 1) + '^' * token_len

    print(line_text)
    print(pointer_line)
    print(f"Error at line {line_num}, column {col_num}: {error.message}")


def parse_source(source_code: str):
    lexer = Lexer(source_code)
    tokens = lexer.tokenize()
    parser = Parser(tokens)
    ast = parser.parse()
    
    source_lines = source_code.splitlines()
    
    # Check for errors
    if parser.errors:
        for error in parser.errors:
            display_error(error, source_lines)
        print("Parsing failed due to errors.")
        return None
    
    return ast

# Test with your example code
if __name__ == "__main__":
    source_code = """extern print(int, string) -> none;
extern strConcat(string, string) -> string;
extern input() -> string;
extern intFromStr(string) -> int;

// Main function - entry point of the program
fn main() -> none
	var prompt: string = "Enter your input: ";  // Prompt message for user input
	return null;                                // End program execution
end"""
    
    ast = parse_source(source_code)
    
    # Print the AST structure
    if ast:
        from pprint import pprint
        pprint(ast, compact=True)
    else:
        print("Parsing failed due to errors.")
    
    # Generate bytecode
    if ast:
        codegen = CodeGenerator(ast)
        bytecode = codegen.generate_code()
        print("Constants:")
        print(codegen.constants)
        print("Generated bytecode:")
        print(bytecode)
        
    